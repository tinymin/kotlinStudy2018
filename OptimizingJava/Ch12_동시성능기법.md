# Chapter 12 동시 성능 기법

- 공짜 점심은 끝났다<sup>The Free Lunch Is Over</sup>

## 12.1 병렬성이란?

> - 순차 실행 파트 = S
> - 자유롭게 사용 가능한 프로세서 개수 = N
> - 총 태스크 소요 시간 = T
> - 프로세서 개수의 함수 = P(N)
 
이 때 태스크 소요시간 식은 아래와 같다.

![](./img/12_exp.png)

- 프로세서를 무한히 증가시켜도 총 소요 작업 시간은 순차 작업 시간 이상 줄어 들 수 없다.

![](./img/12_exp_limit.png)

- 위 식은 암달의 법칙을 뒷받침하는 기반 이론이며, 이를 그림으로 나타내면 [그림 12-2]와 같습니다.

![그림 12-2 암달의 법칙](./img/12_2.png)

- 병렬 태스크나 다른 순차 태스크 간에 소통할 필요가 전혀 없는 경우 이론적으로 속도는 무한히 높일 수 있고, 이런 부류의 워크로드를 `낯간지러운 병렬`<sup>embarrassingly parallel</sup> 이라고 한다.
> 이 책에서는 낯간지러운 병렬이라고 표현하고 있으나 일반적으로는 '처치 곤란 병렬' 이라는 용어를 쓴다. (https://ko.wikipedia.org/wiki/%EC%B2%98%EC%B9%98_%EA%B3%A4%EB%9E%80_%EB%B3%91%EB%A0%AC)

### 12.1.1 자바 동시성 기초

- 멀티스레드 환경에서 아래 코드는 결과를 보장할 수 없다.

```java
public class Counter {
    private int i = 0;
    
    public int increment() {
        return i = i + 1;
    }
}

public class CounterExample implements Runnable {
    private final Counter counter;
    
    public CounterExample(Counter counter) {
        this.counter = counter;
    }
    
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            String tName = Thread.currentThread().getName();
            System.out.println(tname + " Value : " + counter.increment());
        }
    }    
}
```
- 자바 5 이전에는 `synchronized` 키워드로 감싸는 방법이 유일했다.
- 하지만 아무 생각 없이 synchronized만 추가하면 프로그램이 느려질 수도 있다.
- 병렬화 작업을 진행할 때는 성능 테스트가 반드시(!) 수반 되어야 한다.
 




```c
int compare_and_swap(int* reg, int oldval, int newval) {
  int old_reg_val = *reg;
  if (old_reg_val == oldval)
     *reg = newval;
  return old_reg_val;
}
```

```java
int current;
do {
    current = get();
} while(!compareAndSet(current, current + 1));
```

```java
/** AtomicIntegerExample.java **/
package optimize.java;

import sun.misc.Unsafe;

import java.util.concurrent.atomic.AtomicBoolean;

public class AtomicIntegerExample extends Number {
    private volatile int value;

    public static final Unsafe unsafe = Unsafe.getUnsafe();
    public static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset(
                    AtomicIntegerExample.class.getDeclaredField("value"));
        } catch (NoSuchFieldException e) {
            throw new Error(e);
        }
    }

    public final int get() {
        return value;
    }

    public final void set(int newValue) {
        value = newValue;
    }

    public final int getAndSet(int newValue) {
        return unsafe.getAndSetInt(this, valueOffset, newValue);
    }

    private void test() {
        AtomicBoolean locked = new AtomicBoolean(false);

        locked.compareAndSet(false, true);
    }

    @Override
    public int intValue() {
        return 0;
    }

    @Override
    public long longValue() {
        return 0;
    }

    @Override
    public float floatValue() {
        return 0;
    }

    @Override
    public double doubleValue() {
        return 0;
    }
}
```

```java
/** LatchExample.java **/
package optimize.java;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class LatchExample implements Runnable {
    private final CountDownLatch latch;

    public LatchExample(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " Done API Call");
        try {
            latch.countDown();
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " Continue processing");
    }

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch apiLatch = new CountDownLatch(5);


        ExecutorService pool = Executors.newFixedThreadPool(5);
        for (int i=0; i<5; i++) {
            pool.submit(new LatchExample(apiLatch));
        }

        System.out.println(Thread.currentThread().getName() + " about to await on main..");
        apiLatch.await();
        System.out.println(Thread.currentThread().getName() + " done awaiting on main..");
        pool.shutdown();
        pool.awaitTermination(5, TimeUnit.SECONDS);
        System.out.println("API Processing Complete");
    }
}

```