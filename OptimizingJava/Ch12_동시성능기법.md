# Chapter 12 동시 성능 기법

```c
int compare_and_swap(int* reg, int oldval, int newval) {
  int old_reg_val = *reg;
  if (old_reg_val == oldval)
     *reg = newval;
  return old_reg_val;
}
```

```java
int current;
do {
    current = get();
} while(!compareAndSet(current, current + 1));
```

```java
/** AtomicIntegerExample.java **/
package optimize.java;

import sun.misc.Unsafe;

import java.util.concurrent.atomic.AtomicBoolean;

public class AtomicIntegerExample extends Number {
    private volatile int value;

    public static final Unsafe unsafe = Unsafe.getUnsafe();
    public static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset(
                    AtomicIntegerExample.class.getDeclaredField("value"));
        } catch (NoSuchFieldException e) {
            throw new Error(e);
        }
    }

    public final int get() {
        return value;
    }

    public final void set(int newValue) {
        value = newValue;
    }

    public final int getAndSet(int newValue) {
        return unsafe.getAndSetInt(this, valueOffset, newValue);
    }

    private void test() {
        AtomicBoolean locked = new AtomicBoolean(false);

        locked.compareAndSet(false, true);
    }

    @Override
    public int intValue() {
        return 0;
    }

    @Override
    public long longValue() {
        return 0;
    }

    @Override
    public float floatValue() {
        return 0;
    }

    @Override
    public double doubleValue() {
        return 0;
    }
}
```

```java
/** LatchExample.java **/
package optimize.java;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class LatchExample implements Runnable {
    private final CountDownLatch latch;

    public LatchExample(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " Done API Call");
        try {
            latch.countDown();
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " Continue processing");
    }

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch apiLatch = new CountDownLatch(5);


        ExecutorService pool = Executors.newFixedThreadPool(5);
        for (int i=0; i<5; i++) {
            pool.submit(new LatchExample(apiLatch));
        }

        System.out.println(Thread.currentThread().getName() + " about to await on main..");
        apiLatch.await();
        System.out.println(Thread.currentThread().getName() + " done awaiting on main..");
        pool.shutdown();
        pool.awaitTermination(5, TimeUnit.SECONDS);
        System.out.println("API Processing Complete");
    }
}

```